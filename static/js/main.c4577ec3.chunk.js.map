{"version":3,"sources":["Turnips.module.css","turnipCalculator.ts","Chart.tsx","storageService.ts","Turnips.tsx","App.tsx","serviceWorker.js","index.js"],"names":["module","exports","patternNames","predictPattern0","sellPrices","basePrice","predictions","metadata","forEach","hiPhaseLen1","decPhaseLen1","hiPhaseLen3","hiPhaseLen2and3","decPhaseLen2","push","blankPrediction","i","variation","length","config","work","Math","floor","ceil","minRate","maxRate","predictPattern1","peakStart","predictPattern2","predictPattern3","patternProbability","lastPattern","possiblePatterns","startPrice","patterns","prob","idx","patternsTemp","prediction","pattern","dailyPriceRange","probability","type","high","low","totalProb","reduce","a","b","expectedPrice","day","expectedPrices","expectedPricesHigh","expectedPricesLow","startDay","expectedMax","expectedHigh","expectedLow","expected","min","max","price","dailyPredictedPrice","Chart","props","d3Container","useRef","useEffect","width","margin","top","right","bottom","left","height","svg","d3","current","attr","append","x","domain","range","call","tickFormat","d","y","style","text","data","title","areas","area","datum","undefined","opacity","y0","y1","lines","line","main","className","ref","memoryStore","USE_LOCAL_STORE","localStorage","getStore","dataStr","getItem","JSON","parse","setStore","value","setItem","stringify","turnipPriceStore","key","expiration","Date","now","clear","storageService","PriceForm","useState","setLastPattern","prices","filter","Boolean","setPrices","changePrice","e","newPrices","parseFloat","target","delay","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout","useDebounce","store","onChange","parseInt","patternSelect","map","name","selected","priceTable","formDay","dayName","Turnips","currentDay","currentPrice","p","charts","round","masterChart","c","chart","unshift","recommendation","color","App","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.c4577ec3.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"priceTable\":\"Turnips_priceTable__1R06m\",\"formDay\":\"Turnips_formDay__1WR1H\",\"recommendation\":\"Turnips_recommendation__1YEcW\",\"patternSelect\":\"Turnips_patternSelect__1x5LR\"};","// https://gist.github.com/Treeki/85be14d297c80c8b3c0a76375743325b\n\nconst randbool = () => Math.random() > 0.5;\nconst randint = (low: number, high: number) =>\n  Math.floor(Math.random() * (high - low + 1)) + low;\nconst intceil = (num: number) => Math.ceil(num);\nconst randfloat = (low: number, high: number) =>\n  Math.random() * (high - low) + low;\n\ninterface Pattern {\n  dailyPriceRange: { low: number; high: number }[];\n  probability: number;\n  type: number; // 0|1|2|3;\n}\n\nexport const patternNames = [\n  \"Random\",\n  \"Large Spike\",\n  \"Decreasing\",\n  \"Small Spike\",\n  \"Unknown\"\n];\n\n// 0.9 - 1.4 random\nfunction pattern0(basePrice: number) {\n  let sellPrices = [basePrice, basePrice];\n  // PATTERN 0: high, decreasing, high, decreasing, high\n  let work = 2;\n\n  const hiPhaseLen1 = randint(0, 6);\n  const decPhaseLen1 = randbool() ? 3 : 2;\n  const hiPhaseLen2and3 = 7 - hiPhaseLen1;\n  const decPhaseLen2 = 5 - decPhaseLen1;\n  const hiPhaseLen3 = randint(0, hiPhaseLen2and3 - 1);\n\n  // high phase 1\n  for (let i = 0; i < hiPhaseLen1; i++) {\n    sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n  }\n\n  // decreasing phase 1\n  let rate = randfloat(0.8, 0.6);\n  for (let i = 0; i < decPhaseLen1; i++) {\n    sellPrices[work++] = intceil(rate * basePrice);\n    rate -= 0.04;\n    rate -= randfloat(0, 0.06);\n  }\n\n  // high phase 2\n  for (let i = 0; i < hiPhaseLen2and3 - hiPhaseLen3; i++) {\n    sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n  }\n\n  // decreasing phase 2\n  rate = randfloat(0.8, 0.6);\n  for (let i = 0; i < decPhaseLen2; i++) {\n    sellPrices[work++] = intceil(rate * basePrice);\n    rate -= 0.04;\n    rate -= randfloat(0, 0.06);\n  }\n\n  // high phase 3\n  for (let i = 0; i < hiPhaseLen3; i++) {\n    sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n  }\n  sellPrices.shift();\n  sellPrices.shift();\n  return sellPrices;\n}\nfunction predictPattern0(sellPrices: number[]) {\n  const basePrice = sellPrices[0];\n  // [low, high] x 14 vals x prediction trees\n  let predictions: [number, number][][] = [];\n  let metadata: {\n    decPhaseLen1: number;\n    hiPhaseLen1: number;\n    hiPhaseLen3: number;\n    hiPhaseLen2and3: number;\n    decPhaseLen2: number;\n  }[] = [];\n\n  [0, 1, 2, 3, 4, 5, 6].forEach(hiPhaseLen1 => {\n    [2, 3].forEach(decPhaseLen1 => {\n      [0, 1, 2, 3, 4, 5, 6].forEach(hiPhaseLen3 => {\n        const hiPhaseLen2and3 = 7 - hiPhaseLen1;\n        const decPhaseLen2 = 5 - decPhaseLen1;\n        if (hiPhaseLen3 > hiPhaseLen2and3 - 1) return;\n\n        metadata.push({\n          decPhaseLen1,\n          hiPhaseLen1,\n          hiPhaseLen3,\n          hiPhaseLen2and3,\n          decPhaseLen2\n        });\n        let blankPrediction: typeof predictions[0] = [];\n        for (let i = 0; i < 14; i++)\n          blankPrediction.push([sellPrices[i], sellPrices[i]]);\n        predictions.push(blankPrediction);\n      });\n    });\n  });\n\n  for (let variation = 0; variation < metadata.length; variation++) {\n    const config = metadata[variation];\n\n    // high phase 1\n    let work = 2;\n    for (let i = 0; i < config.hiPhaseLen1; i++) {\n      if (!sellPrices[work]) {\n        predictions[variation][work][0] = Math.floor(0.9 * basePrice);\n        predictions[variation][work][1] = Math.ceil(1.4 * basePrice);\n      }\n      work++;\n    }\n\n    // decreasing phase 1\n    let minRate = 0.6;\n    let maxRate = 0.8;\n    for (let i = 0; i < config.decPhaseLen1; i++) {\n      if (!sellPrices[work]) {\n        predictions[variation][work][0] = Math.floor(minRate * basePrice);\n        predictions[variation][work][1] = Math.ceil(maxRate * basePrice);\n      }\n      minRate -= 0.04 + 0.06;\n      maxRate -= 0.04;\n      work++;\n    }\n\n    // high phase 2\n    for (let i = 0; i < config.hiPhaseLen2and3 - config.hiPhaseLen3; i++) {\n      if (!sellPrices[work]) {\n        predictions[variation][work][0] = Math.floor(0.9 * basePrice);\n        predictions[variation][work][1] = Math.ceil(1.4 * basePrice);\n      }\n      work++;\n    }\n\n    // decreasing phase 2\n    minRate = 0.6;\n    maxRate = 0.8;\n    for (let i = 0; i < config.decPhaseLen2; i++) {\n      if (!sellPrices[work]) {\n        predictions[variation][work][0] = Math.floor(minRate * basePrice);\n        predictions[variation][work][1] = Math.ceil(maxRate * basePrice);\n      }\n      minRate -= 0.04 + 0.06;\n      maxRate -= 0.04;\n      work++;\n    }\n    // high phase 3\n    for (let i = 0; i < config.hiPhaseLen3; i++) {\n      if (!sellPrices[work]) {\n        predictions[variation][work][0] = Math.floor(0.9 * basePrice);\n        predictions[variation][work][1] = Math.ceil(1.4 * basePrice);\n      }\n      work++;\n    }\n  }\n\n  return predictions;\n}\n// 2.0 - 6.0 large spike\nfunction pattern1(basePrice: number) {\n  let sellPrices = [basePrice, basePrice];\n  // PATTERN 1: decreasing middle, high spike, random low\n  const peakStart = randint(3, 9);\n  let rate = randfloat(0.9, 0.85);\n  let work = 2;\n  for (; work < peakStart; work++) {\n    sellPrices[work] = intceil(rate * basePrice);\n    rate -= 0.03;\n    rate -= randfloat(0, 0.02);\n  }\n  sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n  sellPrices[work++] = intceil(randfloat(1.4, 2.0) * basePrice);\n  sellPrices[work++] = intceil(randfloat(2.0, 6.0) * basePrice);\n  sellPrices[work++] = intceil(randfloat(1.4, 2.0) * basePrice);\n  sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n  for (; work < 14; work++) {\n    sellPrices[work] = intceil(randfloat(0.4, 0.9) * basePrice);\n  }\n  sellPrices.shift();\n  sellPrices.shift();\n  return sellPrices;\n}\nfunction predictPattern1(sellPrices: number[]) {\n  const basePrice = sellPrices[0];\n  // [low, high] x 14 vals x prediction trees\n  let predictions: [number, number][][] = [];\n  let metadata: { peakStart: number }[] = [];\n\n  [3, 4, 5, 6, 7, 8, 9].forEach(peakStart => {\n    metadata.push({ peakStart });\n    let blankPrediction: typeof predictions[0] = [];\n    for (let i = 0; i < 14; i++)\n      blankPrediction.push([sellPrices[i], sellPrices[i]]);\n    predictions.push(blankPrediction);\n  });\n\n  for (let variation = 0; variation < metadata.length; variation++) {\n    const config = metadata[variation];\n    let minRate = 0.85;\n    let maxRate = 0.9;\n    let work = 2;\n    for (; work < config.peakStart; work++) {\n      if (!sellPrices[work]) {\n        predictions[variation][work][0] = Math.floor(minRate * basePrice);\n        predictions[variation][work][1] = Math.ceil(maxRate * basePrice);\n      }\n      minRate -= 0.03 + 0.02;\n      maxRate -= 0.03;\n    }\n\n    if (!sellPrices[work]) {\n      predictions[variation][work][0] = Math.floor(0.9 * basePrice);\n      predictions[variation][work][1] = Math.ceil(1.4 * basePrice);\n    }\n    work++;\n    if (!sellPrices[work]) {\n      predictions[variation][work][0] = Math.floor(1.4 * basePrice);\n      predictions[variation][work][1] = Math.ceil(2.0 * basePrice);\n    }\n    work++;\n    if (!sellPrices[work]) {\n      predictions[variation][work][0] = Math.floor(2.0 * basePrice);\n      predictions[variation][work][1] = Math.ceil(6.0 * basePrice);\n    }\n    work++;\n    if (!sellPrices[work]) {\n      predictions[variation][work][0] = Math.floor(1.4 * basePrice);\n      predictions[variation][work][1] = Math.ceil(2.0 * basePrice);\n    }\n    work++;\n    if (!sellPrices[work]) {\n      predictions[variation][work][0] = Math.floor(0.9 * basePrice);\n      predictions[variation][work][1] = Math.ceil(1.4 * basePrice);\n    }\n    work++;\n\n    for (; work < 14; work++) {\n      if (!sellPrices[work]) {\n        predictions[variation][work][0] = Math.floor(0.4 * basePrice);\n        predictions[variation][work][1] = Math.ceil(0.9 * basePrice);\n      }\n    }\n  }\n\n  return predictions;\n}\n// 0.9 - 0.3 decreasing\nfunction pattern2(basePrice: number) {\n  let sellPrices = [basePrice, basePrice];\n  // PATTERN 2: consistently decreasing\n  let rate = 0.9;\n  rate -= randfloat(0, 0.05);\n  for (let work = 2; work < 14; work++) {\n    sellPrices[work] = intceil(rate * basePrice);\n    rate -= 0.03;\n    rate -= randfloat(0, 0.02);\n  }\n  sellPrices.shift();\n  sellPrices.shift();\n  return sellPrices;\n}\nfunction predictPattern2(sellPrices: number[]) {\n  const basePrice = sellPrices[0];\n  // [low, high] x 14 vals x prediction trees\n  let predictions: [number, number][][] = [];\n\n  let blankPrediction: typeof predictions[0] = [];\n  for (let i = 0; i < 14; i++)\n    blankPrediction.push([sellPrices[i], sellPrices[i]]);\n  predictions.push(blankPrediction);\n\n  let minRate = 0.9;\n  let maxRate = 0.9;\n\n  minRate -= 0.05;\n  maxRate -= 0;\n  for (let work = 2; work < 14; work++) {\n    for (let variation = 0; variation < predictions.length; variation++) {\n      if (!sellPrices[work]) {\n        predictions[variation][work][0] = Math.floor(minRate * basePrice);\n        predictions[variation][work][1] = Math.ceil(maxRate * basePrice);\n      }\n    }\n    minRate -= 0.03 + 0.02;\n    maxRate -= 0.03;\n  }\n  return predictions;\n}\n// 1.4 - 2.0 small spike\nfunction pattern3(basePrice: number) {\n  let sellPrices = [basePrice, basePrice];\n  // PATTERN 3: decreasing, spike, decreasing\n  const peakStart = randint(2, 9);\n\n  // decreasing phase before the peak\n  let rate = randfloat(0.9, 0.4);\n  let work = 2;\n  for (; work < peakStart; work++) {\n    sellPrices[work] = intceil(rate * basePrice);\n    rate -= 0.03;\n    rate -= randfloat(0, 0.02);\n  }\n\n  sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n  sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n  rate = randfloat(1.4, 2.0);\n  sellPrices[work++] = intceil(randfloat(1.4, rate) * basePrice) - 1;\n  sellPrices[work++] = intceil(rate * basePrice);\n  sellPrices[work++] = intceil(randfloat(1.4, rate) * basePrice) - 1;\n\n  // decreasing phase after the peak\n  if (work < 14) {\n    rate = randfloat(0.9, 0.4);\n    for (; work < 14; work++) {\n      sellPrices[work] = intceil(rate * basePrice);\n      rate -= 0.03;\n      rate -= randfloat(0, 0.02);\n    }\n  }\n\n  sellPrices.shift();\n  sellPrices.shift();\n  return sellPrices;\n}\nfunction predictPattern3(sellPrices: number[]) {\n  const basePrice = sellPrices[0];\n  // [low, high] x 14 vals x prediction trees\n  let predictions: [number, number][][] = [];\n  let metadata: { peakStart: number }[] = [];\n\n  [2, 3, 4, 5, 6, 7, 8, 9].forEach(peakStart => {\n    metadata.push({ peakStart });\n    let blankPrediction: typeof predictions[0] = [];\n    for (let i = 0; i < 14; i++)\n      blankPrediction.push([sellPrices[i], sellPrices[i]]);\n    predictions.push(blankPrediction);\n  });\n\n  for (let variation = 0; variation < metadata.length; variation++) {\n    const config = metadata[variation];\n    let minRate = 0.4;\n    let maxRate = 0.9;\n    let work = 2;\n    for (; work < config.peakStart; work++) {\n      if (!sellPrices[work]) {\n        predictions[variation][work][0] = Math.floor(minRate * basePrice);\n        predictions[variation][work][1] = Math.ceil(maxRate * basePrice);\n      }\n      minRate -= 0.03 + 0.02;\n      maxRate -= 0.03;\n    }\n\n    if (!sellPrices[work]) {\n      predictions[variation][work][0] = Math.floor(0.9 * basePrice);\n      predictions[variation][work][1] = Math.ceil(1.4 * basePrice);\n    }\n    work++;\n    if (!sellPrices[work]) {\n      predictions[variation][work][0] = Math.floor(0.9 * basePrice);\n      predictions[variation][work][1] = Math.ceil(1.4 * basePrice);\n    }\n    work++;\n    if (!sellPrices[work]) {\n      predictions[variation][work][0] = Math.floor(1.4 * basePrice) - 1;\n      predictions[variation][work][1] = Math.ceil(2 * basePrice) - 1;\n    }\n    work++;\n    if (!sellPrices[work]) {\n      predictions[variation][work][0] = Math.floor(1.4 * basePrice);\n      predictions[variation][work][1] = Math.ceil(2 * basePrice);\n    }\n    work++;\n    if (!sellPrices[work]) {\n      predictions[variation][work][0] = Math.floor(1.4 * basePrice) - 1;\n      predictions[variation][work][1] = Math.ceil(2 * basePrice) - 1;\n    }\n    work++;\n\n    if (work < 14) {\n      minRate = 0.4;\n      maxRate = 0.9;\n      for (; work < 14; work++) {\n        if (!sellPrices[work]) {\n          predictions[variation][work][0] = Math.floor(minRate * basePrice);\n          predictions[variation][work][1] = Math.ceil(maxRate * basePrice);\n        }\n        minRate -= 0.03 + 0.02;\n        maxRate -= 0.03;\n      }\n    }\n  }\n\n  return predictions;\n}\nfunction predictPattern(pattern: number, sellPrices: number[]) {\n  if (pattern === 0) return predictPattern0(sellPrices);\n  if (pattern === 1) return predictPattern1(sellPrices);\n  if (pattern === 2) return predictPattern2(sellPrices);\n  if (pattern === 3) return predictPattern3(sellPrices);\n  return [];\n}\nfunction whichPattern(lastPattern: number) {\n  const chance = randint(0, 99);\n  switch (lastPattern) {\n    case 0:\n      if (chance < 20) return 0; // 20\n      if (chance < 50) return 1; // 30\n      if (chance < 65) return 2; // 15\n      return 3; // 35\n    case 1:\n      if (chance < 50) return 0; // 50\n      if (chance < 55) return 1; // 5\n      if (chance < 75) return 2; // 20\n      return 3; // 25\n    case 2:\n      if (chance < 25) return 0; // 25\n      if (chance < 70) return 1; // 45\n      if (chance < 75) return 2; // 5\n      return 3; // 25\n    case 3:\n      if (chance < 45) return 0; // 45\n      if (chance < 70) return 1; // 25\n      if (chance < 85) return 2; // 15\n      return 3; // 15\n  }\n  return 2;\n}\n// [\n//   \"Random\",\n//   \"Large Spike\",\n//   \"Decreasing\",\n//   \"Small Spike\"\n// ];\nfunction patternProbability(lastPattern: number) {\n  if (lastPattern === 0) return [0.2, 0.3, 0.15, 0.35];\n  if (lastPattern === 1) return [0.5, 0.05, 0.2, 0.25];\n  if (lastPattern === 2) return [0.25, 0.45, 0.05, 0.25];\n  if (lastPattern === 3) return [0.45, 0.25, 0.15, 0.15];\n  return [0.35, 0.25, 0.15, 0.25];\n}\nfunction startPrice() {\n  return randint(90, 110);\n}\n\n// [buy, buy, mon am, mon pm, tue am, tue pm...]\nexport function possiblePatterns(\n  sellPrices: number[],\n  lastPattern: number = -1\n) {\n  const startPrice = [...sellPrices];\n  for (let i = 2; i < startPrice.length; i++) startPrice[i] = 0;\n  const predictions = [\n    predictPattern0(startPrice),\n    predictPattern1(startPrice),\n    predictPattern2(startPrice),\n    predictPattern3(startPrice)\n  ];\n\n  // let text: string[] = [];\n  // let csv: string[] = [];\n  let patterns: Pattern[] = [];\n\n  const prob = patternProbability(lastPattern);\n\n  // has 4 patterns\n  predictions.forEach((predictions, idx) => {\n    const patternsTemp: typeof patterns = [];\n\n    // all predictions in this pattern\n    predictions.forEach(prediction => {\n      const pattern: typeof patterns[0] = {\n        dailyPriceRange: [],\n        probability: 0,\n        type: idx\n      };\n\n      // daily prediction\n      for (let i = 0; i < 2; i++) {\n        pattern.dailyPriceRange.push({\n          high: sellPrices[i],\n          low: sellPrices[i]\n        });\n      }\n      for (let i = 2; i < prediction.length; i++) {\n        const low = prediction[i][0];\n        const high = prediction[i][1];\n\n        // skip if not within range\n        if (sellPrices[i] && sellPrices[i] < low) return;\n        if (sellPrices[i] && sellPrices[i] > high) return;\n\n        pattern.dailyPriceRange.push({\n          high: high,\n          low: low\n        });\n      }\n      // this is a valid pattern, add it\n      patternsTemp.push(pattern);\n    });\n\n    // probability of each pattern in the prediction\n    patternsTemp.forEach(pattern => {\n      pattern.probability = prob[idx] / patternsTemp.length;\n    });\n\n    patterns.push(...patternsTemp);\n  });\n\n  // normalize probabilities\n  const totalProb = patterns.reduce((a, b) => a + b.probability, 0);\n  patterns.forEach(\n    pattern => (pattern.probability = pattern.probability / totalProb)\n  );\n\n  return { patterns };\n}\n\nexport function dailyPredictedPrice(patterns: Pattern[]) {\n  let expectedPrices: number[] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  let expectedPricesHigh: number[] = [];\n  let expectedPricesLow: number[] = [];\n  patterns.forEach(pattern => {\n    for (let startDay = 2; startDay < 14; startDay++) {\n      let expectedMax = 0;\n      let expectedHigh = 0;\n      let expectedLow = 0;\n      for (let day = startDay; day < 14; day++) {\n        const high = pattern.dailyPriceRange[day].high;\n        const low = pattern.dailyPriceRange[day].low;\n        const expected = (high + low) / 2;\n        if (expectedMax < expected) {\n          expectedMax = expected;\n          expectedHigh = high;\n          expectedLow = low;\n        }\n      }\n      expectedPrices[startDay] += expectedMax * pattern.probability;\n      expectedPricesLow[startDay] = Math.min(\n        expectedPricesLow[startDay] || 99999,\n        expectedLow\n      );\n      expectedPricesHigh[startDay] = Math.max(\n        expectedPricesHigh[startDay] || 0,\n        expectedHigh\n      );\n    }\n  });\n  return {\n    price: expectedPrices,\n    low: expectedPricesLow,\n    high: expectedPricesHigh\n  };\n}\n\nexport function expectedPrice(patterns: Pattern[], day: number) {\n  const expectedPrices = dailyPredictedPrice(patterns);\n  let expected = 0;\n  let high = 0;\n  let low = 0;\n  for (let i = day; i < 14; i++) {\n    if (expectedPrices.price[i] > expected) {\n      expected = expectedPrices.price[i];\n      high = expectedPrices.high[i];\n      low = expectedPrices.low[i];\n    }\n  }\n  return { expected, high, low };\n}\n\nexport function simulation() {\n  let pattern = 2;\n\n  const RUNS = 1000;\n  let totalProfit = 0;\n\n  for (let i = 0; i < RUNS; i++) {\n    const basePrice = startPrice();\n    const result =\n      pattern === 0\n        ? pattern0(basePrice)\n        : pattern === 1\n        ? pattern1(basePrice)\n        : pattern === 2\n        ? pattern2(basePrice)\n        : pattern === 3\n        ? pattern3(basePrice)\n        : [];\n\n    result.unshift(basePrice);\n    result.unshift(basePrice);\n\n    for (let i = 3; i < 14; i++) {\n      const knownData = [...result];\n      for (let j = i; j < 14; j++) knownData[j] = 0;\n      const { patterns } = possiblePatterns(knownData);\n      const { expected } = expectedPrice(patterns, i + 1);\n      const price = result[i];\n      // if (price > 125 || i === 13) {\n      //   const gain = Math.floor((1000 * (price - basePrice)) / basePrice) / 10;\n      //   totalProfit += gain;\n      //   console.log(\n      //     `Sell on day ${i - 2} at price ${price} return of ${gain}%`\n      //   );\n      //   break;\n      // }\n      if (expected <= price || i === 13) {\n        const gain = Math.floor((1000 * (price - basePrice)) / basePrice) / 10;\n        totalProfit += gain;\n        console.log(\n          `Sell on day ${i - 2} at price ${price} return of ${gain}%`\n        );\n        break;\n      }\n    }\n    pattern = whichPattern(pattern);\n  }\n\n  console.log(\"Expected money from investing $100\", totalProfit / RUNS + 100);\n}\n\n// console.log(possiblePatterns([98, 98, 59, 55, 51, 48, 44, 41, 38, 120, 154]));\n// simulation();\n// console.log(predictPattern0([100, 100]));\n\n// console.log(possiblePatterns([100]).csv.join(\"\\n\"));\n","import React, { useRef, useEffect } from \"react\";\nimport * as d3 from \"d3\";\n// https://www.d3-graph-gallery.com/graph/line_confidence_interval.html\n\ninterface Area {\n  x: number;\n  y0: number;\n  y1: number;\n}\ninterface Line {\n  x: number;\n  y: number;\n}\n\nexport interface ChartData {\n  lines: { data: Line[] }[];\n  areas: { opacity?: number; data: Area[] }[];\n  title: string;\n}\n\ninterface IProps {\n  data: ChartData;\n}\n\nexport const Chart = (props: IProps) => {\n  const d3Container = useRef(null);\n\n  useEffect(() => {\n    async function main() {\n      // set the dimensions and margins of the graph\n      var margin = { top: 10, right: 30, bottom: 30, left: 60 },\n        width = 460 - margin.left - margin.right,\n        height = 400 - margin.top - margin.bottom;\n\n      // append the svg object to the body of the page\n      const svg = d3\n        .select(d3Container.current)\n        .attr(\"width\", width + margin.left + margin.right)\n        .attr(\"height\", height + margin.top + margin.bottom)\n        .append(\"g\")\n        .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n      // Add X axis --> it is a date format\n      var x = d3\n        .scaleLinear()\n        .domain([0, 14])\n        .range([0, width]);\n\n      // x;\n\n      // x.tickFormat(((d: any) => {\n      //   return \"text\" as any;\n      // }) as any);\n\n      svg\n        .append(\"g\")\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\n        .call(\n          d3\n            .axisBottom(x)\n            .tickFormat(\n              d =>\n                [\n                  \"Buy\",\n                  \"\",\n                  \"Mon\",\n                  \"\",\n                  \"Tue\",\n                  \"\",\n                  \"Wed\",\n                  \"\",\n                  \"Thu\",\n                  \"\",\n                  \"Fri\",\n                  \"\",\n                  \"Sat\",\n                  \"\"\n                ][d as number]\n            )\n        );\n\n      // Add Y axis\n      var y = d3\n        .scaleLinear()\n        .domain([0, 600])\n        .range([height, 0]);\n      svg.append(\"g\").call(d3.axisLeft(y));\n\n      svg\n        .append(\"text\")\n        .attr(\"x\", width / 2)\n        .attr(\"y\", 0 + margin.top)\n        .attr(\"text-anchor\", \"middle\")\n        .style(\"font-size\", \"16px\")\n        .text(props.data.title);\n\n      props.data.areas.forEach(area => {\n        svg\n          .append(\"path\")\n          .datum(area.data)\n          .attr(\"fill\", \"#cce5df\")\n          .attr(\"stroke\", \"none\")\n          .attr(\"opacity\", area.opacity !== undefined ? area.opacity : 1)\n          .attr(\n            \"d\",\n            d3\n              .area<Area>()\n              .x(d => x(d.x))\n              .y0(d => y(d.y0))\n              .y1(d => y(d.y1))\n          );\n      });\n\n      props.data.lines.forEach(line => {\n        svg\n          .append(\"path\")\n          .datum(line.data)\n          .attr(\"fill\", \"none\")\n          .attr(\"stroke\", \"steelblue\")\n          .attr(\"stroke-width\", 1.5)\n          .attr(\n            \"d\",\n            d3\n              .line<Line>()\n              .x(d => x(d.x))\n              .y(d => y(d.y))\n          );\n      });\n    }\n    if (props.data && d3Container.current) {\n      main();\n    }\n  }, [props.data, d3Container.current]);\n\n  return (\n    <>\n      <svg\n        className=\"d3-component\"\n        width={400}\n        height={200}\n        ref={d3Container}\n      />\n    </>\n  );\n};\n\n// /* App */\n// export const MyApp = () => {\n//   return (\n//     <div className=\"my-app\">\n//       <MyD3Component data={[1, 2, 3]} />\n//     </div>\n//   );\n// };\n","interface StorageItem {\n  expiration: number;\n  value: any;\n}\n\ninterface DataStore {\n  [prop: string]: StorageItem;\n}\n\nlet memoryStore: DataStore = {};\n\nconst USE_LOCAL_STORE = typeof localStorage !== \"undefined\";\nconst LOCAL_STORE_KEY = \"MONETFE_DATA_STORE\";\nconst VALUE_EXPIRATION = 14 * 24 * 60 * 60 * 1000;\nconst EXPIRATION_CHECK_INTERVAL = 60 * 60 * 1000;\n\nlet lastExpirationCheck = 0;\nfunction checkForExpired() {\n  if (Date.now() < lastExpirationCheck + EXPIRATION_CHECK_INTERVAL) return;\n  const store = getStore();\n  Object.keys(store).forEach(key => {\n    if (store[key].expiration < Date.now()) delete store[key];\n  });\n  setStore(store);\n  lastExpirationCheck = Date.now();\n}\n\nfunction getStore(): DataStore {\n  if (USE_LOCAL_STORE) {\n    const dataStr = localStorage.getItem(LOCAL_STORE_KEY);\n    if (dataStr) return JSON.parse(dataStr);\n  }\n  return memoryStore;\n}\n\nfunction setStore(value: DataStore) {\n  memoryStore = value;\n  if (USE_LOCAL_STORE) {\n    localStorage.setItem(LOCAL_STORE_KEY, JSON.stringify(value));\n  }\n}\n\nfunction set(key: string, value: any, expiration = VALUE_EXPIRATION) {\n  const store = getStore();\n  store[key] = {\n    expiration: Date.now() + expiration,\n    value\n  };\n  setStore(store);\n  return value;\n}\n\nfunction get(key: string) {\n  const data = getStore()[key];\n  if (!data) return;\n  if (data.expiration < Date.now()) return clear(key);\n  return data.value;\n}\n\nfunction clear(key: string) {\n  const data = getStore();\n  delete data[key];\n  setStore(data);\n}\n\nexport { set, get, clear, checkForExpired };\n","import React, { useEffect, useState } from \"react\";\nimport {\n  possiblePatterns,\n  patternNames,\n  expectedPrice\n} from \"./turnipCalculator\";\nimport { Chart, ChartData } from \"./Chart\";\nimport * as storageService from \"./storageService\";\n\nimport style from \"./Turnips.module.css\";\n\nconst turnipPriceStore = storageService.get(\"turnipPriceStore\");\n\nconst PriceForm = (props: {\n  onChange: { (price: number[], lastPattern: number): unknown };\n}) => {\n  const [lastPattern, setLastPattern] = useState(\n    turnipPriceStore?.lastPattern || 4\n  );\n  const [prices, setPrices] = useState<number[]>(\n    turnipPriceStore?.prices?.filter(Boolean) || [100, 100]\n  );\n  const changePrice = (day: number) => (e: { target: { value: string } }) => {\n    const newPrices = [...prices];\n    newPrices[day] = parseFloat(e.target.value);\n    if (day === 0) newPrices[1] = newPrices[0] || (undefined as any);\n    setPrices(newPrices);\n  };\n  useDebounce(() => {\n    storageService.set(\"turnipPriceStore\", { prices, lastPattern });\n    props.onChange(prices, lastPattern);\n  }, 1000);\n  return (\n    <>\n      <div>\n        Last week's pattern:{\" \"}\n        <select\n          onChange={e => setLastPattern(parseInt(e.target.value))}\n          className={style.patternSelect}\n        >\n          {patternNames.map((name, idx) => (\n            <option selected={idx === lastPattern} value={idx}>\n              {name}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className={style.priceTable}>\n        <span className={style.formDay}>\n          <input\n            type=\"text\"\n            value={prices[0] || \"\"}\n            onChange={changePrice(0)}\n          />\n          <div className={style.dayName}>Buy Price</div>\n        </span>\n        <span className={style.formDay}>\n          <input\n            type=\"text\"\n            value={prices[2] || \"\"}\n            onChange={changePrice(2)}\n          />\n          <input\n            type=\"text\"\n            value={prices[3] || \"\"}\n            onChange={changePrice(3)}\n          />\n          <div className={style.dayName}>Monday</div>\n        </span>\n        <span className={style.formDay}>\n          <input\n            type=\"text\"\n            value={prices[4] || \"\"}\n            onChange={changePrice(4)}\n          />\n          <input\n            type=\"text\"\n            value={prices[5] || \"\"}\n            onChange={changePrice(5)}\n          />\n          <div className={style.dayName}>Tuesday</div>\n        </span>\n        <span className={style.formDay}>\n          <input\n            type=\"text\"\n            value={prices[6] || \"\"}\n            onChange={changePrice(6)}\n          />\n          <input\n            type=\"text\"\n            value={prices[7] || \"\"}\n            onChange={changePrice(7)}\n          />\n          <div className={style.dayName}>Wednesday</div>\n        </span>\n        <span className={style.formDay}>\n          <input\n            type=\"text\"\n            value={prices[8] || \"\"}\n            onChange={changePrice(8)}\n          />\n          <input\n            type=\"text\"\n            value={prices[9] || \"\"}\n            onChange={changePrice(9)}\n          />\n          <div className={style.dayName}>Thursday</div>\n        </span>\n        <span className={style.formDay}>\n          <input\n            type=\"text\"\n            value={prices[10] || \"\"}\n            onChange={changePrice(10)}\n          />\n          <input\n            type=\"text\"\n            value={prices[11] || \"\"}\n            onChange={changePrice(11)}\n          />\n          <div className={style.dayName}>Friday</div>\n        </span>\n        <span className={style.formDay}>\n          <input\n            type=\"text\"\n            value={prices[12] || \"\"}\n            onChange={changePrice(12)}\n          />\n          <input\n            type=\"text\"\n            value={prices[13] || \"\"}\n            onChange={changePrice(13)}\n          />\n          <div className={style.dayName}>Saturday</div>\n        </span>\n      </div>\n    </>\n  );\n};\n\nfunction useDebounce(value: any, delay: number) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value]);\n\n  return debouncedValue;\n}\n\nexport const Turnips = () => {\n  // [\n  //   \"Random\",\n  //   \"Large Spike\",\n  //   \"Decreasing\",\n  //   \"Small Spike\"\n  // ];\n  const [lastPattern, setLastPattern] = useState(4);\n  const [prices, setPrices] = useState<number[]>([]);\n  // const prices = [98, 98]; // , 59, 55, 51, 48, 44, 41, 38, 120, 117, 154\n  let currentDay = 0;\n  let currentPrice = 0;\n  prices.forEach((p, i) => {\n    if (p) {\n      currentDay = i;\n      currentPrice = p;\n    }\n  });\n  const { patterns } = possiblePatterns(prices, lastPattern);\n\n  const expected = expectedPrice(patterns, currentDay + 1);\n\n  // if (patterns.length > 1) {\n  //   const masterPattern = cloneDeep(patterns[0]);\n  //   patterns.forEach(pattern => {\n  //     pattern.forEach((val, i) => {\n  //       if (masterPattern[i].high < val.high) masterPattern[i].high = val.high;\n  //       if (masterPattern[i].low > val.low) masterPattern[i].low = val.low;\n  //     });\n  //   });\n  //   patterns.unshift(masterPattern);\n  // }\n\n  const charts: ChartData[] = patterns.map(pattern => {\n    const area = pattern.dailyPriceRange.map((p, i) => ({\n      x: i,\n      y0: p.low as number,\n      y1: p.high as number\n    }));\n    return {\n      lines: [\n        {\n          data: pattern.dailyPriceRange.map((p, i) => ({ x: i, y: prices[i] }))\n        }\n      ],\n      areas: [{ data: area, opacity: pattern.probability * 4 }],\n      title: `${patternNames[pattern.type]} (${Math.round(\n        pattern.probability * 1000\n      ) / 10}%)`\n    };\n  });\n\n  if (patterns.length > 1) {\n    const masterChart: ChartData = {\n      lines: [\n        {\n          data: patterns[0].dailyPriceRange.map((p, i) => ({\n            x: i,\n            y: prices[i]\n          }))\n        }\n      ],\n      areas: charts.map(c => c.areas[0]),\n      title: \"All Possible Prices\"\n    };\n    charts.forEach(\n      chart => (chart.areas[0] = { ...chart.areas[0], opacity: 1 })\n    );\n    charts.unshift(masterChart);\n  }\n\n  return (\n    <>\n      <h1>Animal Crossing New Horizons Turnip Price Calculator</h1>\n      <PriceForm\n        onChange={(prices, pattern) => {\n          setPrices(prices);\n          setLastPattern(pattern);\n        }}\n      />\n      <div className={style.recommendation}>\n        {expected.expected > currentPrice\n          ? `Recommendation is to hold.`\n          : `Sell Now!!`}\n        Prices are expected to be <b>{Math.round(expected.expected)}</b> in the\n        future with a low of{\" \"}\n        <span style={{ color: \"red\" }}>{expected.low}</span> and a high of{\" \"}\n        <span style={{ color: \"green\" }}>{expected.high}</span>.\n      </div>\n      {charts.map((chart, idx) => {\n        return <Chart key={`${idx}-${JSON.stringify(chart)}`} data={chart} />;\n      })}\n    </>\n  );\n};\n","import React from \"react\";\nimport \"./App.css\";\nimport { Turnips } from \"./Turnips\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Turnips />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}